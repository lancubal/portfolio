const sessionManager = require('./sessionManager');

const VISUALIZATIONS = {
    'bubble': {
        name: "Bubble Sort (C)",
        file: 'bubble.c',
        code: [
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include <unistd.h>',
            '',
            '#define SIZE 10',
            '#define DELAY 150000',
            '',
            'void print_array(int arr[], int size, int active1, int active2) {',
            '    puts("Visualizing Bubble Sort (C)");',
            '    puts("Description: Compares adjacent pairs and swaps them if they are in the wrong order.");',
            '    puts("             Largest values \"bubble up\" to the end of the list.");',
            '    puts("---------------------------------------------------------------------------");',
            '    for (int i = 0; i < size; i++) {',
            '        for (int j = 0; j < arr[i]; j++) printf("#");',
            '        printf(" (%d)", arr[i]);',
            '        if (i == active1 || i == active2) printf(" <--");',
            '        puts("");',
            '    }',
            '    puts("");',
            '    fflush(stdout);',
            '}',
            '',
            'int main() {',
            '    int arr[SIZE] = {9, 3, 5, 1, 8, 2, 7, 4, 10, 6};',
            '    for (int i = 0; i < SIZE - 1; i++) {',
            '        for (int j = 0; j < SIZE - i - 1; j++) {',
            '            print_array(arr, SIZE, j, j + 1);',
            '            usleep(DELAY);',
            '            if (arr[j] > arr[j + 1]) {',
            '                int temp = arr[j];',
            '                arr[j] = arr[j + 1];',
            '                arr[j + 1] = temp;',
            '                print_array(arr, SIZE, j, j + 1);',
            '                usleep(DELAY);',
            '            }',
            '        }',
            '    }',
            '    print_array(arr, SIZE, -1, -1);',
            '    puts("Sorted!");',
            '    return 0;',
            '}'
        ].join('\n')
    },
    'selection': {
        name: "Selection Sort (C)",
        file: 'selection.c',
        code: [
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include <unistd.h>',
            '',
            '#define SIZE 10',
            '#define DELAY 200000',
            '',
            'void print_array(int arr[], int size, int min_idx, int current) {',
            '    puts("Visualizing Selection Sort (C)");',
            '    puts("Description: Repeatedly finds the minimum element from the unsorted part");',
            '    puts("             and puts it at the beginning of the sorted portion.");',
            '    puts("---------------------------------------------------------------------------");',
            '    for (int i = 0; i < size; i++) {',
            '        for (int j = 0; j < arr[i]; j++) printf("#");',
            '        printf(" (%d)", arr[i]);',
            '        if (i == min_idx) printf(" <-- [MIN]");',
            '        else if (i == current) printf(" <-- [SCAN]");',
            '        puts("");',
            '    }',
            '    puts("");',
            '    fflush(stdout);',
            '}',
            '',
            'int main() {',
            '    int arr[SIZE] = {7, 2, 9, 1, 5, 10, 4, 3, 8, 6};',
            '    for (int i = 0; i < SIZE - 1; i++) {',
            '        int min_idx = i;',
            '        for (int j = i + 1; j < SIZE; j++) {',
            '            print_array(arr, SIZE, min_idx, j);',
            '            usleep(DELAY);',
            '            if (arr[j] < arr[min_idx]) min_idx = j;',
            '        }',
            '        int temp = arr[min_idx];',
            '        arr[min_idx] = arr[i];',
            '        arr[i] = temp;',
            '    }',
            '    print_array(arr, SIZE, -1, -1);',
            '    puts("Sorted!");',
            '    return 0;',
            '}'
        ].join('\n')
    },
    'quick': {
        name: "Quick Sort (C)",
        file: 'quick.c',
        code: [
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include <unistd.h>',
            '',
            '#define SIZE 10',
            '#define DELAY 250000',
            '',
            'void print_array(int arr[], int size, int p, int low, int high) {',
            '    puts("Visualizing Quick Sort (C)");',
            '    puts("Description: Divide and Conquer! Partitions the array around a pivot");',
            '    puts("             so that elements smaller than pivot are on the left.");',
            '    puts("---------------------------------------------------------------------------");',
            '    for (int i = 0; i < size; i++) {',
            '        for (int j = 0; j < arr[i]; j++) printf("#");',
            '        printf(" (%d)", arr[i]);',
            '        if (i == p) printf(" <-- [PIVOT]");',
            '        else if (i >= low && i <= high) printf(" <--");',
            '        puts("");',
            '    }',
            '    puts("");',
            '    fflush(stdout);',
            '}',
            '',
            'int partition(int arr[], int low, int high, int size) {',
            '    int pivot = arr[high];',
            '    int i = (low - 1);',
            '    for (int j = low; j <= high - 1; j++) {',
            '        print_array(arr, size, high, i+1, j);',
            '        usleep(DELAY);',
            '        if (arr[j] < pivot) {',
            '            i++;',
            '            int t = arr[i]; arr[i] = arr[j]; arr[j] = t;',
            '        }',
            '    }',
            '    int t = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = t;',
            '    return (i + 1);',
            '}',
            '',
            'void quickSort(int arr[], int low, int high, int size) {',
            '    if (low < high) {',
            '        int pi = partition(arr, low, high, size);',
            '        quickSort(arr, low, pi - 1, size);',
            '        quickSort(arr, pi + 1, high, size);',
            '    }',
            '}',
            '',
            'int main() {',
            '    int arr[SIZE] = {10, 7, 8, 9, 1, 5, 2, 4, 3, 6};',
            '    quickSort(arr, 0, SIZE - 1, SIZE);',
            '    print_array(arr, SIZE, -1, -1, -1);',
            '    puts("Sorted!");',
            '    return 0;',
            '}'
        ].join('\n')
    },
    'pathfinder': {
        name: "BFS Pathfinding (C)",
        file: 'pathfinder.c',
        code: [
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include <unistd.h>',
            '',
            '#define ROWS 7',
            '#define COLS 15',
            '#define DELAY 100000',
            '',
            'char grid[ROWS][COLS];',
            'int visited[ROWS][COLS];',
            '',
            'void print_grid() {',
            '    puts("Visualizing BFS Pathfinding (C)");',
            '    puts("Description: Explores all neighboring nodes at the present depth before");',
            '    puts("             moving on to nodes at the next depth level. Guaranteed shortest path.");',
            '    puts("---------------------------------------------------------------------------");',
            '    for (int i = 0; i < ROWS; i++) {',
            '        for (int j = 0; j < COLS; j++) {',
            '            printf("%c ", grid[i][j]);',
            '        }',
            '        puts("");',
            '    }',
            '    puts("");',
            '    fflush(stdout);',
            '}',
            '',
            'int main() {',
            '    // Initialize grid',
            '    for(int i=0; i<ROWS; i++) for(int j=0; j<COLS; j++) { grid[i][j] = \'.\'; visited[i][j] = 0; }',
            '    ',
            '    int startR = 3, startC = 2;',
            '    int endR = 3, endC = 12;',
            '    grid[startR][startC] = \'S\';',
            '    grid[endR][endC] = \'E\';',
            '    ',
            '    // BFS Queue simulation',
            '    int qR[100], qC[100];',
            '    int head=0, tail=0;',
            '    ',
            '    qR[tail] = startR; qC[tail] = startC; tail++;',
            '    visited[startR][startC] = 1;',
            '    ',
            '    int dr[] = {-1, 1, 0, 0};',
            '    int dc[] = {0, 0, -1, 1};',
            '    ',
            '    while(head < tail) {',
            '        int r = qR[head]; int c = qC[head]; head++;',
            '        ',
            '        if (r == endR && c == endC) break;',
            '        ',
            '        if (grid[r][c] == \'.\') grid[r][c] = \'*\';',
            '        ',
            '        print_grid();',
            '        usleep(DELAY);',
            '        ',
            '        for(int i=0; i<4; i++) {',
            '            int nr = r + dr[i]; int nc = c + dc[i];',
            '            if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc]) {',
            '                visited[nr][nc] = 1;',
            '                qR[tail] = nr; qC[tail] = nc; tail++;',
            '            }',
            '        }',
            '    }',
            '    ',
            '    puts("Target found!");',
            '    return 0;',
            '}'
        ].join('\n')
    }
};

class VisualizationManager {
    async prepareVisualization(sessionId, vizId) {
        const viz = VISUALIZATIONS[vizId];
        if (!viz) throw new Error("Visualization not found.");
        const b64 = Buffer.from(viz.code).toString('base64');
        await sessionManager.executeCommand(sessionId, `echo "${b64}" | base64 -d > ${viz.file}`);
        const compileCmd = `gcc ${viz.file} -o ${vizId}_app`;
        const result = await sessionManager.executeCommand(sessionId, compileCmd);
        if (result.error) throw new Error(`Compilation failed: ${result.error}`);
        return `./${vizId}_app`;
    }
}

module.exports = new VisualizationManager();
